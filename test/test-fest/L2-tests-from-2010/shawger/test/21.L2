;; this is the (stupid) recursive version of fib, ie:
;;   fib(0) = 1
;;   fib(1) = 1
;;   fib(n) = fib(n-1) + fib(n-2)
;; it computes the answer as a regular L1 number and
;; then encodes the number just before calling print

(((rax <- 10)   ;; initial argument to fib.
  (call :fib)   ;; the call
  (rax += rax)  ;; encode & print
  (rax += 1)
  (rax <- (print rax)))
 (:fib
  (cjump rax < 2 :base :recur)
  :base            ;; non-recursive case
  (rax <- 1)       ;; store result
  (return)         ;; return
  :recur           ;; recursive case
  (arg <- rax)     ;; save the argument
  (arg -= 1)       ;; decrement the argument
  (rax <- arg)     ;; prepare the argument
  (call :fib)      ;; make first recursive call
  (result <- rax)  ;; save the result of first call
  (arg -= 1)       ;; decrement the arg again
  (rax <- arg)     ;; prepare the argument
  (call :fib)      ;; call
  (rax += result)  ;; sum the two results
  (return)))       ;; and we're done.
